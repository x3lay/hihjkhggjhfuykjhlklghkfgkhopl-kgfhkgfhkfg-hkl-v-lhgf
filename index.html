<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <title>Burini Smart — ИИ‑чат</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <!-- Tailwind CSS (for modern, responsive utility classes) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://kit.fontawesome.com/a7d8ec7750.js" crossorigin="anonymous"></script>
    
    <!-- Firebase/Firestore Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, collection, query, orderBy, limit, onSnapshot, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- Глобальные переменные Firebase (Обязательно для Immersive Canvas) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        if (firebaseConfig) {
            window.firebaseApp = initializeApp(firebaseConfig);
            window.db = getFirestore(window.firebaseApp);
            window.auth = getAuth(window.firebaseApp);

            // Аутентификация
            onAuthStateChanged(window.auth, async (user) => {
                if (user) {
                    window.userId = user.uid;
                } else if (initialAuthToken) {
                    try {
                        await signInWithCustomToken(window.auth, initialAuthToken);
                        window.userId = window.auth.currentUser.uid;
                    } catch (error) {
                        console.error("Custom token sign-in failed, falling back to anonymous:", error);
                        await signInAnonymously(window.auth);
                        window.userId = window.auth.currentUser.uid;
                    }
                } else {
                    await signInAnonymously(window.auth);
                    window.userId = window.auth.currentUser.uid;
                }
                
                // После успешной аутентификации инициализируем основное приложение
                if (window.userId) {
                    console.log("Authenticated with user ID:", window.userId);
                    window.dispatchEvent(new Event('authReady'));
                }
            });
        }
    </script>
    <style>
        /* ===== Design system: Grok 2.0 (Perfected Dark Theme) ===== */
        :root {
            --bg: #000000;
            --layer1: rgba(10, 10, 15, 0.95); /* Deep background */
            --layer2: rgba(25, 25, 30, 0.90); /* Input/Chat bubbles */
            --layer3: rgba(40, 40, 50, 0.85); /* Hover/Code background */
            --text: #ffffff;
            --muted: #a0a0b0;
            --accent: #f49c00; /* Richer, deep orange */
            --border: rgba(255, 255, 255, 0.08);
            --ok: #00d084;
            --danger: #ff4757;
            --radius: 1rem; /* 16px */
            --shadow-deep: 0 10px 30px rgba(0,0,0,0.8);
        }

        /* Звездный Фон (Subtle Parallax Effect) */
        #stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(2px 2px at 20px 30px, var(--text), rgba(0,0,0,0)),
                radial-gradient(2px 2px at 40px 70px, var(--muted), rgba(0,0,0,0)),
                radial-gradient(1px 1px at 50px 160px, var(--text), rgba(0,0,0,0)),
                radial-gradient(2px 2px at 90px 40px, var(--muted), rgba(0,0,0,0)),
                radial-gradient(1px 1px at 100px 100px, var(--text), rgba(0,0,0,0));
            background-repeat: repeat;
            background-size: 200px 200px;
            pointer-events: none;
            z-index: 0;
            animation: moveStars 180s linear infinite;
            opacity: 0.2;
        }

        @keyframes moveStars {
            from { background-position: 0 0; }
            to { background-position: 1000px 1000px; }
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg);
            color: var(--text);
            height: 100vh;
            overflow: hidden; 
            position: relative;
        }
        
        #app-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 10;
        }

        /* Sidebar Styling and Responsiveness */
        #sidebar {
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translateX(-100%);
            z-index: 50;
            box-shadow: var(--shadow-deep);
        }

        #sidebar.open {
            transform: translateX(0);
        }

        /* Main Content and Header */
        header {
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            background-color: var(--layer1);
        }

        #input-panel {
            box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.7);
            background: linear-gradient(to top, var(--layer1), rgba(10, 10, 15, 0.8));
        }

        /* Chat Message Styling */
        .chat-bubble {
            max-width: 85%;
            border-radius: var(--radius);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }
        .chat-bubble code {
            background-color: var(--layer3);
            color: var(--accent);
            padding: 0.1rem 0.4rem;
            border-radius: 0.4rem;
            font-size: 0.875rem;
        }

        /* Mode Buttons Styling */
        .mode-btn {
            padding: 0.5rem 1rem;
            border-radius: 1rem;
            transition: all 0.2s ease;
            font-size: 0.875rem;
        }
        .mode-btn:not(.active) {
            background-color: var(--layer2);
            color: var(--muted);
            border: 1px solid var(--border);
        }
        .mode-btn.active {
            background-color: var(--accent);
            color: var(--layer1); /* Dark text on bright accent */
            font-weight: 700;
            box-shadow: 0 0 15px rgba(244, 156, 0, 0.4);
        }

        /* Scrollbar styles (for WebKit browsers) */
        .scrollbar-thin::-webkit-scrollbar { width: 6px; }
        .scrollbar-thin::-webkit-scrollbar-track { background: var(--layer1); }
        .scrollbar-thin::-webkit-scrollbar-thumb { background: var(--layer3); border-radius: 3px; }
        .scrollbar-thin::-webkit-scrollbar-thumb:hover { background: var(--accent); }

        /* Settings Panel */
        #settings-panel > div {
            transform: translateY(0);
        }

        @media (min-width: 768px) {
            #sidebar {
                position: static;
                transform: translateX(0);
                width: 280px;
            }
            #app-container {
                flex-direction: row;
            }
            #menu-btn, #sidebar-overlay {
                display: none !important;
            }
        }
    </style>
</head>
<body class="bg-black">
    <div id="stars"></div>
    <div id="app-container">
        
        <!-- Затемнение для мобильного меню -->
        <div id="sidebar-overlay" class="fixed top-0 left-0 w-full h-full bg-black/60 z-40 opacity-0 pointer-events-none transition-opacity duration-300" onclick="toggleSidebar(false)"></div>

        <!-- Боковое меню чатов (Sidebar) -->
        <aside id="sidebar" class="fixed top-0 left-0 w-4/5 max-w-xs md:static bg-[var(--layer1)] flex flex-col border-r border-[var(--border)] h-full">
            <div class="p-4 flex items-center justify-between border-b border-[var(--border)]">
                <h2 class="text-2xl font-black text-[var(--accent)] tracking-widest">BURINI</h2>
                <button id="close-sidebar-btn" class="md:hidden text-white hover:text-[var(--accent)] p-2 rounded-full transition-colors">
                    <i class="fa-solid fa-xmark text-2xl"></i>
                </button>
            </div>
            
            <div id="chat-list" class="flex-grow overflow-y-auto space-y-2 p-3 scrollbar-thin">
                <button id="new-chat-btn" class="w-full bg-[var(--layer2)] text-white border-2 border-[var(--border)] hover:bg-[var(--layer3)] transition-all p-3 rounded-xl font-medium mb-3 shadow-lg active:scale-[0.98]">
                    <i class="fa-solid fa-plus mr-2 text-[var(--accent)]"></i> Начать новый чат
                </button>
                <!-- Список чатов будет здесь -->
            </div>

            <!-- Блок настроек внизу сайдбара -->
            <div class="p-4 border-t border-[var(--border)]">
                <div class="text-[var(--muted)] text-xs mb-2 truncate">ID: <span id="display-user-id" class="font-mono text-white text-sm">...</span></div>
                <button id="settings-btn" class="w-full text-left p-3 rounded-xl hover:bg-[var(--layer3)] transition-colors text-white flex items-center justify-between">
                    <span class="font-medium"><i class="fa-solid fa-cog mr-2 text-[var(--accent)]"></i> Настройки</span>
                    <i class="fa-solid fa-chevron-right text-xs"></i>
                </button>
            </div>
        </aside>

        <!-- Основной контент (Chat Main) -->
        <main id="chat-main" class="flex-grow flex flex-col overflow-hidden">
            <!-- Шапка чата -->
            <header class="p-3 flex items-center justify-between sticky top-0 z-30 border-b border-[var(--border)]">
                <div class="flex items-center space-x-3">
                    <button id="menu-btn" class="md:hidden text-white hover:text-[var(--accent)] p-2 rounded-full transition-colors">
                        <i class="fa-solid fa-bars text-xl"></i>
                    </button>
                    <h1 id="chat-title" class="text-xl font-bold truncate max-w-[180px] sm:max-w-full">Burini AI Chat</h1>
                </div>
                <span id="user-badge" class="text-xs font-mono bg-[var(--accent)] text-black px-3 py-1 rounded-full font-bold shadow-md">FREE TIER</span>
            </header>

            <!-- Контейнер сообщений -->
            <div id="messages-container" class="flex-grow overflow-y-auto p-4 space-y-5 scrollbar-thin">
                <!-- Сообщения будут здесь -->
            </div>

            <!-- Панель ввода -->
            <div id="input-panel" class="p-4 border-t border-[var(--border)]">
                <!-- Выбор режима/модели -->
                <div id="mode-selector" class="flex flex-wrap gap-2 mb-3 justify-center p-2 rounded-xl bg-black/50 border border-[var(--border)]">
                    <button class="mode-btn" data-mode="smart" data-model="x-ai/grok-4-fast:free">
                        <span class="mode-text">🚀 Smart Chat</span>
                    </button>
                    <button class="mode-btn" data-mode="vision" data-model="deepseek/deepseek-chat-v3.1:free">
                        <span class="mode-text">👁️ Vision</span>
                    </button>
                    <button class="mode-btn" data-mode="studio" data-model="mistralai/mistral-7b-instruct-v0.2">
                        <span class="mode-text">💻 Code Studio</span>
                    </button>
                </div>

                <div class="flex items-end space-x-2">
                    <textarea id="prompt-input" class="flex-grow bg-[var(--layer2)] text-white placeholder-gray-500 rounded-xl p-3 resize-none focus:ring-2 focus:ring-[var(--accent)] focus:outline-none max-h-40 overflow-y-auto text-base border border-[var(--border)]" rows="1" placeholder="Ваше сообщение..."></textarea>
                    <button id="send-btn" class="bg-[var(--accent)] text-black w-12 h-12 rounded-full flex items-center justify-center transition-all disabled:opacity-50 hover:bg-yellow-500 active:scale-90 shadow-xl focus:ring-2 focus:ring-[var(--accent)]">
                        <i class="fa-solid fa-paper-plane text-xl"></i>
                    </button>
                </div>
            </div>
        </main>

        <!-- Панель настроек (Settings Panel) -->
        <div id="settings-panel" class="fixed inset-0 bg-black/90 backdrop-blur-sm z-[100] transform transition-opacity duration-300 opacity-0 pointer-events-none flex items-center justify-center">
            <div class="bg-[var(--layer1)] p-6 rounded-2xl shadow-2xl w-full max-w-sm m-4 transform translate-y-0 transition-transform duration-500 border border-[var(--border)]">
                <h3 class="text-2xl font-bold mb-6 text-[var(--accent)] border-b border-[var(--border)] pb-2">Настройки Приложения</h3>
                
                <div class="space-y-5">
                    
                    <!-- Основная модель LLM -->
                    <div>
                        <label for="model-select" class="block text-white mb-2 font-medium">Основная модель (по умолчанию)</label>
                        <select id="model-select" class="w-full bg-[var(--layer2)] text-white p-3 rounded-xl border border-[var(--border)] focus:ring-[var(--accent)] focus:border-[var(--accent)]">
                            <option value="x-ai/grok-4-fast:free">Grok-4 Fast (Быстрый)</option>
                            <option value="deepseek/deepseek-chat-v3.1:free">DeepSeek (Vision/Code)</option>
                            <option value="mistralai/mistral-7b-instruct-v0.2">Mistral 7B (Эконом)</option>
                        </select>
                    </div>

                    <!-- Звездный Фон Toggle -->
                    <div class="flex justify-between items-center bg-[var(--layer2)] p-3 rounded-xl border border-[var(--border)]">
                        <label for="stars-toggle" class="text-white font-medium">Космический фон</label>
                        <input type="checkbox" id="stars-toggle" class="h-5 w-5 text-[var(--accent)] rounded focus:ring-[var(--accent)] bg-gray-600 border-gray-700" checked>
                    </div>

                    <!-- Уведомления -->
                    <div class="flex justify-between items-center bg-[var(--layer2)] p-3 rounded-xl border border-[var(--border)]">
                        <label for="notify-toggle" class="text-white font-medium">Показывать уведомления</label>
                        <input type="checkbox" id="notify-toggle" class="h-5 w-5 text-[var(--accent)] rounded focus:ring-[var(--accent)] bg-gray-600 border-gray-700" checked>
                    </div>
                </div>

                <button id="close-settings-btn" class="mt-8 w-full bg-[var(--accent)] text-black p-3 rounded-xl font-bold hover:opacity-90 transition-opacity active:scale-[0.98] shadow-md">
                    Закрыть и Сохранить
                </button>
            </div>
        </div>

        <!-- Toast Notification Container -->
        <div id="toast-container" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 z-[1000] w-full max-w-xs px-4">
            <!-- Тосты будут здесь -->
        </div>

    </div>

    <!-- Telegram WebApp Script -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>

    <script type="module">
        // Инициализация Telegram WebApp
        if (window.Telegram && window.Telegram.WebApp) {
            window.Telegram.WebApp.ready();
            window.Telegram.WebApp.expand();
            // Установка цветов для соответствия дизайну
            window.Telegram.WebApp.setHeaderColor('#000000'); 
            window.Telegram.WebApp.setBackgroundColor('#000000');
        } else {
            console.warn("Telegram WebApp object not found. Running in standalone mode.");
        }

        // --- DOM Elements ---
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        const menuBtn = document.getElementById('menu-btn');
        const closeSidebarBtn = document.getElementById('close-sidebar-btn');
        const messagesContainer = document.getElementById('messages-container');
        const promptInput = document.getElementById('prompt-input');
        const sendBtn = document.getElementById('send-btn');
        const chatList = document.getElementById('chat-list');
        const newChatBtn = document.getElementById('new-chat-btn');
        const chatTitleEl = document.getElementById('chat-title');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsPanel = document.getElementById('settings-panel');
        const closeSettingsBtn = document.getElementById('close-settings-btn');
        const modelSelect = document.getElementById('model-select');
        const modeButtons = document.querySelectorAll('.mode-btn');
        const starsToggle = document.getElementById('stars-toggle');
        const themeToggle = document.getElementById('theme-toggle'); // Theme toggle is now hidden/unused in this dark-only theme
        const notifyToggle = document.getElementById('notify-toggle');
        const displayUserId = document.getElementById('display-user-id');
        
        // --- State Management ---
        const state = {
            currentChatId: null,
            isTyping: false,
            settings: {
                theme: 'dark', // Fixed to dark
                starsEnabled: true,
                currentModel: 'x-ai/grok-4-fast:free',
                currentMode: 'smart',
                notifications: true,
            },
            chats: {}, 
            userId: null,
            API_URL: '/api/chat', 
        };

        // --- Firestore References ---
        const getChatsCollectionRef = () => collection(window.db, "artifacts", appId, "users", window.userId, "chats");
        const getChatDocRef = (chatId) => doc(window.db, "artifacts", appId, "users", window.userId, "chats", chatId);
        const getMessagesCollectionRef = (chatId) => collection(getChatDocRef(chatId), "messages");

        // --- Utility Functions ---

        /** Переключает боковое меню (открывает/закрывает). */
        function toggleSidebar(open) {
            if (open) {
                sidebar.classList.add('open');
                sidebarOverlay.classList.add('open');
            } else {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('open');
            }
        }

        /** Загружает настройки из Firestore. */
        async function loadSettings() {
            if (!window.db || !window.userId) return;
            displayUserId.textContent = window.userId ? (window.userId.substring(0, 8) + '...') : 'N/A';
            try {
                const settingsDocRef = doc(window.db, "artifacts", appId, "users", window.userId, "metadata", "settings");
                const docSnap = await getDoc(settingsDocRef);
                if (docSnap.exists()) {
                    state.settings = { ...state.settings, ...docSnap.data() };
                }
                applySettings();
            } catch (error) {
                console.error("Error loading settings:", error);
            }
        }

        /** Применяет настройки к DOM. */
        function applySettings() {
            // Stars Toggle
            document.getElementById("stars").style.display = state.settings.starsEnabled ? "block" : "none";
            starsToggle.checked = state.settings.starsEnabled;

            // Notifications Toggle
            notifyToggle.checked = state.settings.notifications;
            
            // Model Select
            modelSelect.value = state.settings.currentModel;

            // Mode Buttons
            modeButtons.forEach(btn => {
                const isSelected = btn.dataset.mode === state.settings.currentMode;
                btn.classList.toggle('active', isSelected);
                // Also update the button's model data if modelSelect changed it
                if (isSelected) {
                     btn.dataset.model = state.settings.currentModel;
                }
            });
        }

        /** Сохраняет настройки в Firestore. */
        async function saveSettings() {
            if (!window.db || !window.userId) return;
            
            state.settings.starsEnabled = starsToggle.checked;
            state.settings.currentModel = modelSelect.value;
            state.settings.notifications = notifyToggle.checked;
            
            // Determine current mode based on model selection if needed
            const activeModeBtn = Array.from(modeButtons).find(btn => btn.dataset.model === state.settings.currentModel);
            if (activeModeBtn) {
                state.settings.currentMode = activeModeBtn.dataset.mode;
            } else {
                 // Fallback if model doesn't match a mode button
                 state.settings.currentMode = 'smart';
            }

            applySettings(); 

            try {
                const settingsDocRef = doc(window.db, "artifacts", appId, "users", window.userId, "metadata", "settings");
                await setDoc(settingsDocRef, state.settings, { merge: true });
                showToast("Настройки сохранены!");
            } catch (error) {
                console.error("Error saving settings:", error);
                showToast("Ошибка сохранения настроек.", 'danger');
            }
        }

        /** Отображение уведомления Toast. */
        function showToast(message, type = 'ok') {
            if (!state.settings.notifications) return;
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `p-3 my-2 rounded-xl text-sm font-medium shadow-2xl transition-all transform duration-300 opacity-0 translate-y-2 ${type === 'ok' ? 'bg-[var(--ok)] text-black' : 'bg-[var(--danger)] text-white'}`;
            toast.textContent = message;
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.classList.remove('opacity-0', 'translate-y-2');
                toast.classList.add('opacity-100', 'translate-y-0');
            }, 10);

            setTimeout(() => {
                toast.classList.remove('opacity-100', 'translate-y-0');
                toast.classList.add('opacity-0', 'translate-y-2');
                toast.addEventListener('transitionend', () => toast.remove());
            }, 3500);
        }

        /** Скроллинг к последнему сообщению. */
        function scrollToBottom() {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // --- Chat Functions ---

        /** Создает новый чат. */
        async function createNewChat() {
            if (!window.db || !window.userId) return showToast("Нет подключения к БД.", 'danger');
            try {
                const chatRef = await addDoc(getChatsCollectionRef(), {
                    title: "Новый чат",
                    createdAt: serverTimestamp(),
                    mode: state.settings.currentMode,
                });
                selectChat(chatRef.id);
            } catch (error) {
                console.error("Error creating new chat:", error);
                showToast("Ошибка при создании чата.", 'danger');
            }
        }

        /** Переключает на выбранный чат. */
        function selectChat(chatId) {
            state.currentChatId = chatId;
            renderChat(chatId);
            // Highlight selected chat in sidebar
            document.querySelectorAll('.chat-item').forEach(el => {
                el.classList.remove('bg-gray-700', 'font-bold');
                if (el.dataset.id === chatId) {
                    el.classList.add('bg-gray-700', 'font-bold');
                }
            });

            if (window.innerWidth < 768) {
                toggleSidebar(false);
            }
        }

        /** Рендерит сообщения текущего чата. */
        function renderChat(chatId) {
            const chat = state.chats[chatId];
            if (!chat) return;

            chatTitleEl.textContent = chat.title || "Новый чат";
            messagesContainer.innerHTML = '';
            
            // Добавляем стартовое сообщение, если чат пуст
            if (chat.messages.length === 0) {
                 messagesContainer.innerHTML = `
                    <div class="text-center text-[var(--muted)] pt-8">
                        <i class="fa-solid fa-robot text-5xl text-[var(--accent)] mb-3 opacity-70"></i>
                        <p class="text-lg font-semibold">Начните диалог с Burini AI.</p>
                        <p class="text-sm mt-1">Текущий режим: <strong>${state.settings.currentMode.toUpperCase()}</strong></p>
                        <p class="text-xs mt-1">Модель: ${state.settings.currentModel.split('/')[1] || 'Grok'}</p>
                    </div>
                 `;
            }

            chat.messages.forEach(msg => {
                messagesContainer.appendChild(createMessageElement(msg));
            });
            scrollToBottom();
        }
        
        /** Создает DOM-элемент сообщения. */
        function createMessageElement(msg) {
            const isUser = msg.role === 'user';
            const bubbleClasses = isUser 
                ? 'bg-[var(--accent)] text-black ml-auto font-medium' 
                : 'bg-[var(--layer2)] mr-auto text-white border border-[var(--border)]';

            const container = document.createElement('div');
            container.className = 'flex ' + (isUser ? 'justify-end' : 'justify-start');

            const bubble = document.createElement('div');
            bubble.className = `chat-bubble p-3 shadow-md ${bubbleClasses}`;
            
            // Преобразование Markdown (базовое)
            let htmlContent = msg.content
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/`(.*?)`/g, '<code class="bg-[var(--layer3)] text-[var(--accent)] px-1 rounded text-sm">$&</code>')
                .replace(/\n/g, '<br>');
                
            bubble.innerHTML = htmlContent;

            container.appendChild(bubble);
            return container;
        }

        /** Добавляет индикатор печати. */
        function addTypingIndicator() {
            const existing = document.getElementById('typing-indicator');
            if (existing) return;

            const container = document.createElement('div');
            container.id = 'typing-indicator';
            container.className = 'flex justify-start mb-4';
            
            const indicator = document.createElement('div');
            indicator.className = 'typing-indicator bg-[var(--layer2)] p-3 rounded-xl shadow-lg flex space-x-1';
            indicator.innerHTML = `
                <span class="w-2 h-2 bg-[var(--accent)] rounded-full"></span>
                <span class="w-2 h-2 bg-[var(--accent)] rounded-full"></span>
                <span class="w-2 h-2 bg-[var(--accent)] rounded-full"></span>
            `;
            container.appendChild(indicator);
            messagesContainer.appendChild(container);
            state.isTyping = true;
            scrollToBottom();
        }

        /** Удаляет индикатор печати. */
        function removeTypingIndicator() {
            const indicator = document.getElementById('typing-indicator');
            if (indicator) {
                indicator.remove();
            }
            state.isTyping = false;
        }

        /** Отправка сообщения LLM API. */
        async function sendMessage() {
            if (state.isTyping || !state.currentChatId) return;

            const userPrompt = promptInput.value.trim();
            if (!userPrompt) return;

            // 1. Сбор истории сообщений для отправки
            const chatMessages = state.chats[state.currentChatId]?.messages || [];
            const apiMessages = chatMessages.map(msg => ({ role: msg.role, content: msg.content }));

            // 2. Добавление сообщения пользователя в UI и DB
            const userMessageData = { role: 'user', content: userPrompt, timestamp: serverTimestamp() };
            const userMessageLocal = { role: 'user', content: userPrompt };
            
            state.chats[state.currentChatId].messages.push(userMessageLocal); 
            renderChat(state.currentChatId);
            
            // Сброс поля ввода
            promptInput.value = '';
            promptInput.style.height = '48px'; // Возврат к исходной высоте
            
            try {
                await addDoc(getMessagesCollectionRef(state.currentChatId), userMessageData);
            } catch (e) {
                console.error("Failed to save user message to Firestore:", e);
                showToast("Ошибка сохранения сообщения в БД.", 'danger');
            }

            // 3. Добавление индикатора печати
            addTypingIndicator();
            sendBtn.disabled = true;

            // 4. API Call
            try {
                const response = await fetch(state.API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: state.settings.currentModel,
                        messages: [...apiMessages, { role: 'user', content: userPrompt }], 
                        mode: state.settings.currentMode, 
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || `API Error: ${response.status}`);
                }

                const data = await response.json();
                const aiResponseText = data.content || "Произошла ошибка при получении ответа от ИИ.";

                // 5. Обработка ответа ИИ
                const aiMessageData = { role: 'assistant', content: aiResponseText, timestamp: serverTimestamp() };
                const aiMessageLocal = { role: 'assistant', content: aiResponseText };
                
                state.chats[state.currentChatId].messages.push(aiMessageLocal); 

                // 6. Сохранение ответа ИИ в DB
                await addDoc(getMessagesCollectionRef(state.currentChatId), aiMessageData);

                // 7. Обновление заголовка чата
                if (chatMessages.length === 0) {
                    const newTitle = userPrompt.substring(0, 30) + (userPrompt.length > 30 ? '...' : '');
                    state.chats[state.currentChatId].title = newTitle;
                    await setDoc(getChatDocRef(state.currentChatId), { title: newTitle }, { merge: true });
                }

            } catch (error) {
                console.error("Chat API error:", error);
                const errorMessage = error.message.includes('API Error') ? error.message : "Произошла ошибка подключения к ИИ.";
                const errorMsgObj = { role: 'assistant', content: `[Ошибка]: ${errorMessage}`, timestamp: serverTimestamp() };
                state.chats[state.currentChatId].messages.push(errorMsgObj);
                await addDoc(getMessagesCollectionRef(state.currentChatId), errorMsgObj);
            } finally {
                // 8. Финализация UI
                removeTypingIndicator();
                sendBtn.disabled = false;
                renderChat(state.currentChatId); 
            }
        }
        
        /** Настройка прослушивания чатов Firestore. */
        function setupFirestoreListeners() {
            if (!window.db || !window.userId) return;

            // 1. Прослушивание списка чатов
            const chatsQuery = query(getChatsCollectionRef(), orderBy("createdAt", "desc"), limit(20));
            onSnapshot(chatsQuery, (snapshot) => {
                chatList.innerHTML = '';
                chatList.appendChild(newChatBtn); 
                
                let firstChatId = null;
                
                snapshot.forEach((doc) => {
                    const chatId = doc.id;
                    const data = doc.data();

                    state.chats[chatId] = state.chats[chatId] || { title: data.title, messages: [] };
                    state.chats[chatId].title = data.title;
                    
                    if (!firstChatId) firstChatId = chatId;
                    
                    // Создание/обновление элемента списка
                    let chatItem = document.querySelector(`.chat-item[data-id="${chatId}"]`);
                    if (!chatItem) {
                        chatItem = document.createElement('button');
                        chatItem.className = 'chat-item w-full text-left p-3 rounded-xl transition-colors truncate hover:bg-[var(--layer3)] active:scale-[0.98]';
                        chatItem.dataset.id = chatId;
                        chatItem.onclick = () => selectChat(chatId);
                        chatList.appendChild(chatItem);
                    }
                    chatItem.innerHTML = `<i class="fa-solid fa-message mr-2 text-[var(--accent)]"></i> ${data.title}`;
                    
                    // 2. Прослушивание сообщений для каждого чата
                    if (!state.chats[chatId].listener) {
                        const messagesQuery = query(getMessagesCollectionRef(chatId), orderBy("timestamp", "asc"));
                        state.chats[chatId].listener = onSnapshot(messagesQuery, (msgSnapshot) => {
                            const messages = [];
                            msgSnapshot.forEach(msgDoc => {
                                messages.push(msgDoc.data());
                            });

                            state.chats[chatId].messages = messages.filter(m => m.content); 
                            
                            // Перерисовка, только если это текущий активный чат
                            if (chatId === state.currentChatId) {
                                renderChat(chatId);
                            }
                        });
                    }
                });
                
                // Инициализация текущего чата
                if (!state.currentChatId && firstChatId) {
                    selectChat(firstChatId);
                } else if (!state.currentChatId && !firstChatId) {
                     // Если чатов нет, создаем новый
                     createNewChat();
                }

            }, (error) => {
                console.error("Error listening to chats:", error);
                showToast("Ошибка загрузки списка чатов.", 'danger');
            });
        }


        // --- Event Listeners and Initialization ---

        window.addEventListener('authReady', () => {
            loadSettings();
            setupFirestoreListeners();
        });

        // Боковое меню для мобильных
        menuBtn.onclick = () => toggleSidebar(true);
        closeSidebarBtn.onclick = () => toggleSidebar(false);

        // Отправка сообщения
        sendBtn.onclick = sendMessage;
        promptInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        
        // Автоматическое изменение высоты textarea
        promptInput.addEventListener('input', function() {
            this.style.height = '48px'; // min-height is 48px (h-12)
            this.style.height = Math.min(this.scrollHeight, 160) + 'px'; // 160px is max-h-40
        });

        // Кнопка "Новый чат"
        newChatBtn.onclick = createNewChat;

        // Панель настроек
        settingsBtn.onclick = () => {
            settingsPanel.classList.remove('opacity-0', 'pointer-events-none');
        };
        closeSettingsBtn.onclick = () => { 
            settingsPanel.classList.add('opacity-0', 'pointer-events-none');
            saveSettings();
        };
        settingsPanel.addEventListener('click', (e) => {
            if (e.target === settingsPanel) { // Закрыть при клике вне модального окна
                settingsPanel.classList.add('opacity-0', 'pointer-events-none');
                saveSettings();
            }
        });

        // Переключение режимов (кнопок)
        modeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const newMode = btn.dataset.mode;
                const newModel = btn.dataset.model;

                state.settings.currentMode = newMode;
                state.settings.currentModel = newModel;
                
                applySettings(); 
                saveSettings(); // Сохраняем в DB
                
                // Перерисовка текущего чата для обновления стартового промпта
                if (state.currentChatId) renderChat(state.currentChatId); 
            });
        });

        // Применение настроек при изменении в селекте
        modelSelect.addEventListener('change', () => {
             saveSettings(); 
             if (state.currentChatId) renderChat(state.currentChatId); 
        });

        // Применение настроек при изменении чекбоксов
        [starsToggle, notifyToggle].forEach(el => el.addEventListener("change", saveSettings));
        
    </script>
</body>
</html>
