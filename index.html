<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Burini Smart — ИИ‑чат</title>
  <!-- Mobile-first viewport for Telegram web apps -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no" />
  <style>
    /* ===== Design system: Dark theme optimized for mobile & Telegram Mini Apps ===== */
    :root {
      --bg: #000000;
      --layer1: rgba(18, 18, 18, 0.95);
      --layer2: rgba(30, 30, 30, 0.90);
      --layer3: rgba(45, 45, 45, 0.85);
      --text: #ffffff;
      --muted: #b0b0b0;
      --primary: #ffffff;
      --accent: #ffb34f;
      --border: rgba(255, 255, 255, 0.1);
      --ok: #00d084;
      --danger: #ff4757;
      --shadow: 0 10px 40px rgba(0,0,0,.5);
      --radius: 12px;
      --fadeIn: fadeIn .2s ease both;
      --slideIn: slideIn .3s ease both;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --tap: 44px; /* min-touch target */
    }
    [data-theme="light"] {
      --bg: #f7fafc;
      --layer1: rgba(255,255,255,0.95);
      --layer2: rgba(245,245,250,0.95);
      --layer3: rgba(230,230,235,0.9);
      --text: #1f2430;
      --muted: #657089;
      --primary: #3b66ff;
      --accent: #ffb34f;
      --border: rgba(59,102,255,0.1);
      --ok: #17a673;
      --danger: #d63f3f;
      --shadow: 0 8px 20px rgba(0,0,0,.12);
    }

    html, body {
      height: 100%;
      background:
        radial-gradient(900px 420px at 12% 0%, rgba(92, 106, 255, 0.10), transparent 60%),
        radial-gradient(700px 340px at 88% 100%, rgba(255, 190, 120, 0.12), transparent 60%),
        var(--bg);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      margin: 0;
      overflow: hidden;
    }

    /* Reduce animation for performance */
    @media (prefers-reduced-motion: reduce) {
      * { animation: none !important; transition: none !important; }
    }

    /* Minimal scrollbar styling */
    * {
      scrollbar-width: thin;
      scrollbar-color: var(--accent) var(--layer3);
    }
    *::-webkit-scrollbar { width: 6px; height: 6px; }
    *::-webkit-scrollbar-thumb { background-color: var(--accent); border-radius: 10px; }
    *::-webkit-scrollbar-track { background: var(--layer3); }

    /* Layout: Mobile-first single-column; sidebar becomes overlay drawer on mobile */
    .app {
      position: relative;
      z-index: 1;
      height: 100vh;
      height: calc(100vh - var(--safe-bottom));
      display: grid;
      grid-template-rows: auto 1fr auto;
    }

    .header {
      padding: calc(8px + var(--safe-top)) 12px 8px 12px;
      display: flex; align-items: center; gap: 8px;
      backdrop-filter: saturate(180%) blur(16px);
      -webkit-backdrop-filter: saturate(180%) blur(16px);
      background: var(--layer1);
      border-bottom: 1px solid var(--border);
      box-shadow: var(--shadow);
      z-index: 5;
    }
    .logo { display: flex; align-items: center; gap: 10px; flex: 0 0 auto; }
    .badge { width: 28px; height: 28px; border-radius: 8px; background: linear-gradient(135deg, var(--text) 0%, var(--accent) 100%); box-shadow: 0 4px 16px rgba(255, 179, 79, 0.3); display: flex; align-items: center; justify-content: center; }
    .badge::before { content: "⚡"; font-size: 16px; }
    .logo-text { font-weight: 700; font-size: 18px; letter-spacing: -0.2px; }

    .search-container { flex: 1; min-width: 0; }
    .search-input {
      width: 100%; padding: 10px 12px; border-radius: 12px;
      border: 1px solid var(--border); background: var(--layer2); color: var(--text);
      outline: none; font-family: inherit; font-size: 14px;
      transition: border-color .2s ease, box-shadow .2s ease;
    }
    .search-input:focus { box-shadow: 0 0 0 2px var(--accent) inset; border-color: var(--accent); }

    .toolbar { display: flex; gap: 6px; }
    .btn {
      display:inline-flex; align-items:center; justify-content:center; gap:6px;
      padding: 10px 12px; min-height: var(--tap);
      border-radius: 12px; border:1px solid var(--border); background: var(--layer2);
      color: var(--text); cursor:pointer; transition: transform .06s ease, opacity .2s ease, box-shadow .2s ease;
      text-decoration: none; font-size: 16px;
      -webkit-tap-highlight-color: transparent;
    }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 6px 14px rgba(0,0,0,.15); }
    .btn.primary { background: var(--accent); border-color: var(--accent); color: var(--bg); font-weight: 600; }
    .btn.danger { background: var(--danger); border-color: var(--danger); color: var(--text); font-weight: 600; }
    .btn.ghost { background: transparent; }
    .btn.icon { width: var(--tap); padding: 0; }

    .mode-buttons { display: none; } /* Hide mode buttons on small screens; moved to settings */
    @media (min-width: 900px) {
      .mode-buttons { display: flex; gap: 6px; margin-left: 6px; }
      .mode-btn { display:flex; align-items:center; gap:6px; padding:8px 10px; border-radius: 16px; border:1px solid var(--border); background: transparent; color: var(--muted); cursor:pointer; font-size: 14px; }
      .mode-btn.active { background: rgba(255, 179, 79, 0.1); color: var(--accent); border-color: var(--accent); }
      .mode-icon { font-size: 16px; }
    }

    /* Sidebar as drawer for mobile */
    .sidebar {
      position: fixed;
      top: 0; left: -100%;
      width: 86vw; max-width: 360px; height: 100%;
      background: var(--layer1); border-right: 1px solid var(--border);
      backdrop-filter: saturate(180%) blur(16px);
      -webkit-backdrop-filter: saturate(180%) blur(16px);
      transition: left .25s ease;
      padding: calc(10px + var(--safe-top)) 12px 12px;
      overflow-y: auto; z-index: 10;
      box-shadow: var(--shadow);
    }
    .sidebar.open { left: 0; animation: var(--slideIn); }
    .side-header { display:flex; align-items:center; justify-content:space-between; font-weight:600; margin-bottom:8px; }
    .chat-list { display:flex; flex-direction:column; gap:8px; }
    .chat-item {
      display:flex; align-items:center; gap:8px; padding:10px 12px; border:1px solid var(--border);
      border-radius: 12px; background: var(--layer2); cursor:pointer; animation: var(--fadeIn);
      box-shadow: 0 4px 8px rgba(0,0,0,.1);
    }
    .chat-item.active { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(255, 179, 79, 0.3) inset; background: rgba(255, 179, 79, 0.05); }
    .chat-title { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .chat-actions { display:flex; gap:6px; }

    /* Chat area */
    .chat {
      display: flex; flex-direction: column;
      overflow-y: auto; padding: 12px; gap: 12px;
      scroll-behavior: smooth;
    }

    /* Composer sticky at bottom with safe-area padding */
    .composer {
      display: flex; flex-direction: column; gap: 8px;
      padding: 10px 12px calc(10px + var(--safe-bottom));
      border-top: 1px solid var(--border); background: var(--layer1);
      backdrop-filter: saturate(180%) blur(16px);
      -webkit-backdrop-filter: saturate(180%) blur(16px);
      z-index: 5;
    }
    .composer-main {
      display: grid; grid-template-columns: auto 1fr auto; gap: 8px; align-items: end;
    }
    .composer textarea {
      width: 100%; resize: none; min-height: 48px; max-height: 40vh;
      border-radius: 12px; border: 1px solid var(--border);
      background: var(--layer2); color: var(--text);
      padding: 10px 12px; outline: none; font-family: inherit; font-size: 16px;
      transition: box-shadow .2s ease, border-color .2s ease; box-sizing: border-box;
    }
    .composer textarea:focus { box-shadow: 0 0 0 2px rgba(255, 179, 79, 0.2) inset; border-color: var(--accent); }
    .btn.upload { padding: 0 10px; font-size: 18px; border-radius: 12px; min-width: var(--tap); min-height: var(--tap); display: flex; align-items: center; justify-content: center; }

    .file-preview { display: none; }
    .file-preview.open {
      display: flex; align-items: center; gap: 10px;
      padding: 8px 12px; background: var(--layer2); border-radius: 10px;
      border: 1px solid var(--border); font-size: 14px;
    }
    .file-preview .file-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .file-preview .remove-btn { color: var(--danger); cursor: pointer; }

    /* Bubbles */
    .bubble {
      max-width: 92%;
      word-wrap: break-word;
      overflow-wrap: break-word;
      padding: 12px 14px;
      border-radius: 16px;
      line-height: 1.6;
      border: 1px solid var(--border);
      background: var(--layer2);
      box-shadow: 0 3px 10px rgba(0,0,0,.25);
      animation: var(--fadeIn);
    }
    .bubble.system { border-left: 4px solid var(--ok); opacity: .95; }
    .bubble.user {
      margin-left: auto;
      background: linear-gradient(180deg, rgba(255, 179, 79, 0.14), rgba(255, 179, 79, 0.08));
      border-left: 4px solid var(--accent);
      border-top-right-radius: 6px;
    }
    .bubble.assistant {
      margin-right: auto;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.04));
      border-left: 4px solid var(--primary);
      border-top-left-radius: 6px;
    }
    .meta { font-size: 13px; color: var(--muted); margin-bottom: 6px; font-weight: 500; }
    .content { white-space: pre-wrap; line-height: 1.6; }
    .content img { max-width: 100%; height: auto; border-radius: 8px; margin-top: 8px; border: 1px solid var(--border); }

    /* Markdown */
    .content strong { font-weight: 700; color: var(--accent); }
    .content em { font-style: italic; }
    .content code {
      background: rgba(255, 255, 255, 0.12);
      padding: 2px 6px; border-radius: 4px;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; font-size: 0.9em;
    }
    .code-block-wrapper { position: relative; margin: 10px 0; border-radius: 8px; overflow: hidden; box-shadow: 0 3px 9px rgba(0,0,0,.2); }
    .code-block-wrapper pre { margin: 0; padding: 14px 10px; background: var(--layer3); overflow-x: auto; font-size: 14px; line-height: 1.4; border: none; white-space: pre; }
    .code-block-wrapper pre code { background: none; padding: 0; font-size: 1em; white-space: pre; display: block; }
    .code-block-wrapper .copy-btn {
      position: absolute; top: 6px; right: 6px; padding: 4px 8px; font-size: 12px;
      color: var(--muted); background: rgba(0,0,0,.5); border: 1px solid var(--border);
      border-radius: 6px; cursor: pointer; opacity: 0.85; transition: opacity .2s, background .2s;
    }
    .code-block-wrapper .copy-btn:hover { opacity: 1; background: var(--layer1); color: var(--text); }

    .content blockquote {
      border-left: 4px solid var(--primary);
      margin: 8px 0; padding-left: 12px; color: var(--muted);
      background: rgba(255, 255, 255, 0.05);
      padding: 8px 12px; border-radius: 8px;
    }
    .content ul, .content ol { margin: 6px 0; padding-left: 18px; }
    .content li { margin: 3px 0; }
    .content h1, .content h2, .content h3 { margin: 12px 0 8px; font-weight: 700; color: var(--primary); }
    .content h1 { font-size: 1.4em; }
    .content h2 { font-size: 1.25em; }
    .content h3 { font-size: 1.1em; }
    .content p { margin: 6px 0; }

    /* Drawer settings (mobile) */
    .settings {
      position: fixed; bottom: 0; right: 0; left: 0;
      max-height: 78vh; transform: translateY(100%);
      background: var(--layer1); border-top: 1px solid var(--border);
      backdrop-filter: saturate(180%) blur(16px);
      -webkit-backdrop-filter: saturate(180%) blur(16px);
      transition: transform .25s ease;
      padding: 12px 12px calc(12px + var(--safe-bottom));
      overflow-y: auto; z-index: 12; box-shadow: var(--shadow);
      border-top-left-radius: 14px; border-top-right-radius: 14px;
    }
    .settings.open { transform: translateY(0); animation: var(--slideIn); }
    .settings h3 { margin: 8px 0 8px; font-size: 15px; color: var(--muted); font-weight: 600; }

    .row { display:flex; align-items:center; justify-content:space-between; gap: 10px; margin:8px 0; }
    select, input[type="text"], textarea.settings-input {
      width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid var(--border);
      background: var(--layer2); color: var(--text); outline: none; font-family: inherit;
      transition: border-color .2s ease, box-shadow .2s ease; font-size: 14px;
    }
    select:focus, input[type="text"]:focus, textarea.settings-input:focus { box-shadow: 0 0 0 2px rgba(255, 179, 79, 0.2) inset; border-color: var(--accent); }
    input[type="checkbox"] { transform: scale(1.2); }

    /* Toast */
    .toast {
      position: fixed; bottom: calc(16px + var(--safe-bottom)); right: 16px;
      padding: 12px 14px; border-radius: 12px; border: 1px solid var(--border);
      background: var(--layer1); box-shadow: var(--shadow); opacity: 0; transform: translateY(8px);
      transition: all .2s ease; pointer-events: none; z-index: 20; font-weight: 500; border-left: 3px solid var(--accent);
    }
    .toast.show { opacity: 1; transform: translateY(0); }

    /* Stars can be disabled on mobile for performance */
    .stars { position: fixed; inset: 0; pointer-events: none; opacity: .12; z-index: 0; display: none; }
    @keyframes twinkle { 0%,100%{opacity:.12} 50%{opacity:.22} }

    /* Animations */
    @keyframes fadeIn { from { opacity: 0; transform: translateY(4px);} to { opacity: 1; transform: translateY(0);} }
    @keyframes slideIn { from { opacity: 0; transform: translateY(8px);} to { opacity: 1; transform: translateY(0);} }
  </style>
</head>
<body data-theme="dark">
  <div class="stars" id="stars"></div>

  <div class="app" id="app">
    <div class="header">
      <button class="btn icon" id="drawerBtn" title="История">☰</button>
      <div class="logo">
        <div class="badge"></div>
        <span class="logo-text">Burini</span>
      </div>
      <div class="search-container">
        <input type="text" id="searchInput" placeholder="Поиск Ctrl+K" class="search-input" />
      </div>
      <div class="toolbar">
        <button class="btn icon" id="newChatBtn" title="Новый чат">💬</button>
        <button class="btn icon" id="settingsBtn" title="Настройки">⚙</button>
      </div>
    </div>

    <aside class="sidebar" id="sidebar">
      <div class="side-header">
        <div>История</div>
        <button class="btn icon" id="closeDrawerBtn" title="Закрыть">✕</button>
      </div>
      <div class="chat-list" id="chatList"></div>
    </aside>

    <main class="chat" id="chat"></main>

    <div class="composer">
      <div class="file-preview" id="filePreview"></div>
      <div class="composer-main">
        <input type="file" id="fileInput" accept=".txt,.md,.json,.xml,.html,.css,.js,.py,.cs,image/png,image/jpeg,image/webp" style="display:none" />
        <button class="btn upload" id="uploadBtn" title="Загрузить файл">📎</button>
        <textarea id="input" placeholder="Напиши сообщение... Shift+Enter — новая строка"></textarea>
        <button class="btn primary" id="sendBtn">Отправить</button>
      </div>
    </div>
  </div>

  <div class="settings" id="settingsPanel">
    <h3>Модель</h3>
    <select id="modelSelect">
      <option value="burini-smart">Burini Fast</option>
      <option value="burini-smart-vision">Burini Think</option>
      <option value="burini-studio">Burini Code</option>
    </select>

    <h3 style="margin-top:10px;">Интерфейс</h3>
    <div class="row"><label>Тёмная тема</label><input type="checkbox" id="themeToggle" checked /></div>
    <div class="row"><label>Звёздный фон</label><input type="checkbox" id="starsToggle" /></div>
    <div class="row"><label>Уведомления</label><input type="checkbox" id="notifyToggle" checked /></div>

    <h3 style="margin-top:10px;">Промпт пользователя (добавляется к системному)</h3>
    <textarea id="userPromptInput" class="settings-input" rows="3" placeholder="Опционально: добавь свой системный промпт для чата"></textarea>
    <div class="row">
      <button class="btn" id="saveUserPromptBtn">Сохранить промпт</button>
      <button class="btn danger" id="clearUserPromptBtn">Очистить</button>
    </div>

    <h3 style="margin-top:10px;">Данные</h3>
    <div class="row"><label>Удалить все чаты</label><button class="btn danger" id="clearChatsBtn">Очистить</button></div>
    <div class="row"><label>Удалить учётку</label><button class="btn danger" id="deleteAccountBtn">Удалить</button></div>
    <div class="row"><label>Открыть историю</label><button class="btn" id="openHistoryBtn">История</button></div>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    // Telegram WebApp integration (safe)
    (function initTelegramWebApp(){
      try {
        if (window.Telegram && window.Telegram.WebApp) {
          const w = window.Telegram.WebApp;
          w.ready();
          // Use theme params if available
          const tp = w.themeParams || {};
          if (tp.bg_color) document.body.style.setProperty('--bg', tp.bg_color);
          if (tp.text_color) document.body.style.setProperty('--text', tp.text_color);
        }
      } catch (e) { /* ignore */ }
    })();

    // Storage
    const store = {
      key: "burini_smart_store_final",
      load() {
        try {
          return JSON.parse(localStorage.getItem(this.key)) || { chats: [], settings: { userPrompt: "" } };
        } catch {
          return { chats: [], settings: { userPrompt: "" } };
        }
      },
      save(d) { localStorage.setItem(this.key, JSON.stringify(d)); },
      clear() { localStorage.removeItem(this.key); },
    };

    // State
    const state = {
      data: store.load(),
      currentChatId: null,
      currentMode: 'smart',
      AFile: null,
      isTyping: false,
      get settings() { return this.data.settings || {}; },
      setSetting(k,v){ this.data.settings[k]=v; store.save(this.data); },
      addChat(initialTitle = "Новая сессия") {
        const id = "chat_" + Date.now();
        this.data.chats.unshift({ id, title: initialTitle, messages: [] });
        this.currentChatId = id; store.save(this.data);
        renderChatList(); renderChat();
        inputEl.focus();
      },
      currentChat(){ return this.data.chats.find(c=>c.id===this.currentChatId); },
      renameCurrent(title) { const c=this.currentChat(); if(!c) return; c.title = title; store.save(this.data); renderChatList(); },
      deleteChat(id) {
        const idx = this.data.chats.findIndex(c => c.id === id);
        if (idx >= 0) this.data.chats.splice(idx,1);
        if (this.currentChatId === id) this.currentChatId = this.data.chats[0]?.id || null;
        store.save(this.data); renderChatList(); renderChat();
      },
      addMessage(role, content){ const chat=this.currentChat(); if(!chat) return; chat.messages.push({ role, content, ts: Date.now() }); store.save(this.data); renderChat(); },
      clearChats(){ this.data.chats=[]; this.currentChatId=null; store.save(this.data); renderChatList(); renderChat(); },
    };

    // Elements
    const chatEl = document.getElementById("chat");
    const chatListEl = document.getElementById("chatList");
    const inputEl = document.getElementById("input");
    const sendBtn = document.getElementById("sendBtn");
    const newChatBtn = document.getElementById("newChatBtn");
    const toastEl = document.getElementById("toast");
    const starsEl = document.getElementById("stars");
    const settingsBtn = document.getElementById("settingsBtn");
    const settingsPanel = document.getElementById("settingsPanel");
    const fileInput = document.getElementById("fileInput");
    const uploadBtn = document.getElementById("uploadBtn");
    const filePreviewEl = document.getElementById("filePreview");
    const themeToggle = document.getElementById("themeToggle");
    const starsToggle = document.getElementById("starsToggle");
    const notifyToggle = document.getElementById("notifyToggle");
    const clearChatsBtn = document.getElementById("clearChatsBtn");
    const deleteAccountBtn = document.getElementById("deleteAccountBtn");
    const modelSelect = document.getElementById("modelSelect");
    const searchInput = document.getElementById("searchInput");
    const userPromptInput = document.getElementById("userPromptInput");
    const saveUserPromptBtn = document.getElementById("saveUserPromptBtn");
    const clearUserPromptBtn = document.getElementById("clearUserPromptBtn");
    const openHistoryBtn = document.getElementById("openHistoryBtn");
    const drawerBtn = document.getElementById("drawerBtn");
    const closeDrawerBtn = document.getElementById("closeDrawerBtn");
    const sidebar = document.getElementById("sidebar");

    // Supported files
    const SUPPORTED_MIMES = {
      image: ['image/png', 'image/jpeg', 'image/webp'],
      text: ['text/plain', 'application/javascript', 'text/css', 'text/html', 'text/x-python', 'text/x-csharp', 'application/json', 'application/xml', 'text/markdown']
    };
    const MAX_IMAGE_SIZE_MB = 8;
    const MAX_TEXT_SIZE_KB = 512;

    // Drawer
    drawerBtn.onclick = () => sidebar.classList.add("open");
    closeDrawerBtn.onclick = () => sidebar.classList.remove("open");
    openHistoryBtn.onclick = () => { sidebar.classList.add("open"); settingsPanel.classList.remove("open"); };

    // Toast
    let toastTimeout = null;
    function showToast(t) {
      clearTimeout(toastTimeout);
      toastEl.textContent = t; toastEl.classList.add("show");
      toastTimeout = setTimeout(()=>toastEl.classList.remove("show"), 2500);
    }
    function notifyUser(t) { if (state.settings.notify !== false) showToast(t); }

    // Custom modals replaced by confirm()/prompt() equivalents where needed – keep UI minimal for mobile

    // File handling
    uploadBtn.onclick = () => fileInput.click();
    fileInput.onchange = handleFileSelect;

    function renderFilePreview() {
      if (!state.AFile) {
        filePreviewEl.classList.remove("open");
        filePreviewEl.innerHTML = '';
        return;
      }
      filePreviewEl.classList.add("open");
      const file = state.AFile;

      let icon = '';
      if (file.type.startsWith('image/')) icon = '🖼️';
      else if (file.type.includes('javascript') || file.type.includes('python') || file.type.includes('html') || file.type.includes('markdown')) icon = '💻';
      else icon = '📄';

      filePreviewEl.innerHTML = `
        <div class="file-preview">
          ${icon}
          <div class="file-name">${file.name}</div>
          <div class="remove-btn" onclick="removeAFile()">✕</div>
        </div>
      `;
    }

    window.removeAFile = () => {
      state.AFile = null;
      fileInput.value = null;
      renderFilePreview();
    }

    async function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;

      const isImage = SUPPORTED_MIMES.image.includes(file.type);
      const isText = SUPPORTED_MIMES.text.includes(file.type);

      if (!isImage && !isText) { showToast(`Неподдерживаемый тип: ${file.type}`); fileInput.value = null; return; }
      if (isImage && file.size > MAX_IMAGE_SIZE_MB * 1024 * 1024) { showToast(`Изображение > ${MAX_IMAGE_SIZE_MB}MB`); fileInput.value = null; return; }
      if (isText && file.size > MAX_TEXT_SIZE_KB * 1024) { showToast(`Текст > ${MAX_TEXT_SIZE_KB/1024}MB`); fileInput.value = null; return; }

      const reader = new FileReader();
      reader.onload = (e) => {
        let contentForAPI = null;
        let contentForUI = null;

        if (isImage) {
          contentForAPI = e.target.result;
          contentForUI = e.target.result;
        } else if (isText) {
          const fileContent = e.target.result;
          const lang = file.type.split('/').pop().replace('x-','').replace('+plain', 'text');
          contentForAPI = `Содержимое файла "${file.name}" (тип: ${file.type}):\n\`\`\`${lang}\n${fileContent}\n\`\`\``;
          contentForUI = `**Прикреплен файл:** \`${file.name}\` (${file.type}).\n\n\`\`\`${lang}\n${fileContent.slice(0, 150).trim()}...\n\`\`\``;
        }

        state.AFile = { name: file.name, type: file.type, contentForAPI, contentForUI };
        renderFilePreview();
      };

      if (isImage) reader.readAsDataURL(file);
      else reader.readAsText(file);
    }

    // Markdown parser (optimized)
    function parseMarkdown(text) {
      if (!text) return '';
      let html = text.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      html = html.replace(/```(\w+)?\n?([\s\S]*?)```/g, (m,lang,content)=> `<div class="code-placeholder" data-lang="${lang||'text'}">${content}</div>`);
      html = html.replace(/^&gt; (.*$)/gim, '<blockquote><p>$1</p></blockquote>');
      html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>').replace(/^## (.*$)/gim, '<h2>$1</h2>').replace(/^# (.*$)/gim, '<h1>$1</h1>');
      html = html.replace(/^[*-] (.*$)/gim, '<li>$1</li>').replace(/^(\d+\.) (.*$)/gim, '<li>$2</li>');
      html = html.replace(/(<li>[\s\S]*?<\/li>(\s*<li>[\s\S]*?<\/li>)*)/gims, m=> '<ul>' + m.trim() + '</ul>');
      html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\*(.*?)\*/g, '<em>$1</em>');
      html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
      html = html.replace(/([^\n])\n([^\n])/g, '$1<br>$2');
      html = html.replace(/\n\n/g, '</p><p>');
      html = '<p>' + html + '</p>';
      html = html.replace(/<p>(\s*<h[1-6]>[\s\S]*?<\/h[1-6]>\s*)<\/p>/g, '$1');
      html = html.replace(/<p>(\s*<blockquote>[\s\S]*?<\/blockquote>\s*)<\/p>/g, '$1');
      html = html.replace(/<p>(\s*<ul[\s\S]*?<\/ul>\s*)<\/p>/g, '$1');
      html = html.replace(/<p>(\s*<div class="code-placeholder"[\s\S]*?<\/div>\s*)<\/p>/g, '$1');
      html = html.replace(/<p><\/p>/g, '');
      html = html.replace(/<ul>\s*<p>/g, '<ul>').replace(/<\/p>\s*<\/ul>/g, '</ul>');
      html = html.replace(/<blockquote>\s*<p>/g, '<blockquote>').replace(/<\/p>\s*<\/blockquote>/g, '</blockquote>');
      return html;
    }

    // Code blocks processing (deferred for performance)
    function processCodeBlocks(bubbleElement) {
      const codePlaceholders = bubbleElement.querySelectorAll('.code-placeholder');
      codePlaceholders.forEach(ph => {
        const content = ph.textContent;
        const lang = ph.dataset.lang;
        const wrapper = document.createElement('div');
        wrapper.className = 'code-block-wrapper';
        const pre = document.createElement('pre');
        const code = document.createElement('code');
        code.textContent = content.trim();
        code.className = `language-${lang}`;
        pre.appendChild(code);
        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-btn';
        copyBtn.textContent = 'Копировать';
        copyBtn.onclick = (e) => {
          e.stopPropagation();
          const textToCopy = code.textContent; 
          navigator.clipboard.writeText(textToCopy).then(() => {
            const originalText = copyBtn.textContent;
            copyBtn.textContent = 'Скопировано!';
            setTimeout(() => copyBtn.textContent = originalText, 1200);
          }).catch(()=>{});
        };
        wrapper.appendChild(pre);
        wrapper.appendChild(copyBtn);
        ph.parentNode.replaceChild(wrapper, ph);
      });
    }

    function appendBubble(role, content, isHtml = false) {
      const bubble = document.createElement("div");
      bubble.className = "bubble " + role;
      const meta = document.createElement("div");
      meta.className = "meta";
      meta.textContent = ({user:"ты",assistant:"burini",system:"система"}[role] || role);
      const body = document.createElement("div");
      body.className = "content";
      body.innerHTML = isHtml ? content : parseMarkdown(content);
      bubble.appendChild(meta); bubble.appendChild(body);
      chatEl.appendChild(bubble);
      // Defer code processing
      if (role === 'assistant') {
        if (window.requestIdleCallback) requestIdleCallback(()=>processCodeBlocks(body));
        else setTimeout(()=>processCodeBlocks(body), 0);
      }
    }

    function renderChat() {
      chatEl.innerHTML = "";
      const chat = state.currentChat();
      if (!chat) {
        const empty = document.createElement("div");
        empty.className = "bubble system";
        empty.innerHTML = '<div class="meta">система</div><div class="content">Создай новый чат и задай первый вопрос. Burini рядом.</div>';
        chatEl.appendChild(empty);
      } else {
        chat.messages.forEach(m => {
          if (Array.isArray(m.content)) {
            const textPart = m.content.find(c => c.type === 'text')?.text || '';
            const imagePart = m.content.find(c => c.type === 'image_url')?.image_url?.url || '';
            const filePart = m.content.find(c => c.type === 'file_content')?.content || '';
            let contentHTML = parseMarkdown(textPart);
            if (imagePart) contentHTML += `<p><img src="${imagePart}" alt="Attached Image"></p>`;
            else if (filePart) contentHTML += parseMarkdown(filePart);
            appendBubble(m.role, contentHTML, true);
          } else {
            appendBubble(m.role, m.content);
          }
        });
      }
      chatEl.scrollTop = chatEl.scrollHeight;
      inputEl.focus();
    }

    async function typeMessage(text, speedMs = 6) {
      const chat = state.currentChat();
      if (!chat) return;
      state.isTyping = true;
      let lastMessage = chat.messages[chat.messages.length - 1];
      if (!lastMessage || lastMessage.role !== "assistant") {
        const msg = { role: "assistant", content: "", ts: Date.now() };
        chat.messages.push(msg); lastMessage = msg;
      }
      const bubble = document.createElement("div");
      bubble.className = "bubble assistant";
      const meta = document.createElement("div");
      meta.className = "meta"; meta.textContent = "burini";
      const contentEl = document.createElement("div");
      contentEl.className = "content";
      bubble.appendChild(meta); bubble.appendChild(contentEl);
      chatEl.appendChild(bubble);

      let i = 0;
      function step() {
        lastMessage.content = text.slice(0, i);
        contentEl.innerHTML = parseMarkdown(lastMessage.content);
        if (window.requestIdleCallback) requestIdleCallback(()=>processCodeBlocks(contentEl));
        else setTimeout(()=>processCodeBlocks(contentEl), 0);
        chatEl.scrollTop = chatEl.scrollHeight;
        i++;
        if (i <= text.length) setTimeout(step, speedMs);
        else { store.save(state.data); notifyUser("Ответ готов ✨"); state.isTyping = false; }
      }
      step();
    }

    async function sendMessage() {
      const text = inputEl.value.trim();
      const file = state.AFile;

      if (!text && !file) { showToast("Введите текст или прикрепите файл."); return; }
      if (state.isTyping) { showToast("Burini уже отвечает, подождите!"); return; }
      if (!state.currentChatId) state.addChat();

      const chat = state.currentChat();
      if (chat && chat.messages.length === 0 && text) state.renameCurrent(text.slice(0, 48));

      let userContentForAPI = [];
      let userContentForUI = [];

      if (text) {
        userContentForAPI.push({ type: "text", text: text });
        userContentForUI.push({ type: "text", text: text });
      }
      if (file) {
        const isImage = file.type.startsWith('image/');
        if (isImage) {
          userContentForAPI.push({ type: "image_url", image_url: { url: file.contentForAPI } });
          userContentForUI.push({ type: "image_url", image_url: { url: file.contentForUI } });
        } else {
          userContentForAPI.push({ type: "text", text: file.contentForAPI });
          userContentForUI.push({ type: "file_content", content: file.contentForUI });
        }
      }

      state.addMessage("user", userContentForUI);

      inputEl.value = ""; inputEl.style.height = '48px'; removeAFile();
      showToast("Готовлю лучший ответ...");

      const messages = chat.messages.map(m => {
        if (m.role === "user" && m.content === userContentForUI) {
          return { role: "user", content: userContentForAPI };
        }
        if (Array.isArray(m.content)) {
          const previousText = m.content.find(c => c.type === 'text')?.text || m.content.find(c => c.type === 'file_content')?.content || '';
          return { role: m.role, content: previousText };
        }
        return { role: m.role, content: m.content };
      }).filter(m => m.content && (typeof m.content === 'string' ? m.content.trim() !== '' : true));

      const s = state.settings;
      try {
        const resp = await fetch("/api/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            messages,
            model: s.model || "burini-smart",
            referer: location.origin,
            title: "Burini Smart",
            userSystemPrompt: s.userPrompt || ""
          }),
        });
        const data = await resp.json();
        if (data.error) {
          const errMsg = data.error.message || JSON.stringify(data.error);
          state.addMessage("assistant", "Ошибка: " + errMsg);
          showToast("Ошибка API! " + errMsg.slice(0, 50) + "...");
          state.isTyping = false;
        } else {
          await typeMessage(data.content, 6);
        }
      } catch (e) {
        state.addMessage("assistant", "Сбой соединения: " + e.message);
        showToast("Сбой соединения: проверьте бэкенд");
        state.isTyping = false;
      }
    }

    // Chat list
    function renderChatList() {
      chatListEl.innerHTML = "";
      const chats = state.data.chats;
      if (!chats.length) {
        const empty = document.createElement("div");
        empty.className = "chat-item";
        empty.style.cursor = "default";
        empty.textContent = "История пуста — создайте новый чат.";
        chatListEl.appendChild(empty);
        return;
      }
      chats.forEach(c => {
        const item = document.createElement("div");
        item.className = "chat-item" + (c.id === state.currentChatId ? " active" : "");
        const title = document.createElement("div");
        title.className = "chat-title";
        title.textContent = c.title || "Без названия";
        const actions = document.createElement("div");
        actions.className = "chat-actions";
        const renameBtn = document.createElement("button");
        renameBtn.className = "btn ghost";
        renameBtn.textContent = "Переим.";
        renameBtn.onclick = async (e) => {
          e.stopPropagation();
          const nv = prompt("Новое название чата:", c.title || "");
          if (nv !== null) { c.title = (nv.trim() || "Без названия"); store.save(state.data); renderChatList(); }
        };
        const delBtn = document.createElement("button");
        delBtn.className = "btn danger";
        delBtn.textContent = "✕";
        delBtn.onclick = async (e) => {
          e.stopPropagation();
          if (confirm("Удалить этот чат?")) state.deleteChat(c.id);
        };
        actions.appendChild(renameBtn);
        actions.appendChild(delBtn);
        item.appendChild(title);
        item.appendChild(actions);
        item.onclick = (e) => {
          if (e.target.closest('.chat-actions')) return;
          state.currentChatId = c.id; renderChatList(); renderChat(); sidebar.classList.remove("open");
        };
        chatListEl.appendChild(item);
      });
    }

    // Settings load/save
    function loadSettings() {
      const s = state.settings;
      document.body.setAttribute("data-theme", (s.theme || "dark"));
      themeToggle.checked = (s.theme || "dark") === "dark";
      starsEl.style.display = s.stars ? "block" : "none";
      starsToggle.checked = !!s.stars;
      notifyToggle.checked = s.notify !== false;
      modelSelect.value = s.model || "burini-smart";
      userPromptInput.value = s.userPrompt || "";
    }
    function saveSettings() {
      state.setSetting("theme", themeToggle.checked ? "dark" : "light");
      state.setSetting("stars", starsToggle.checked);
      state.setSetting("notify", notifyToggle.checked);
      state.setSetting("model", modelSelect.value);
      loadSettings();
    }
    saveUserPromptBtn.onclick = () => { state.setSetting("userPrompt", userPromptInput.value.trim()); showToast("Промпт сохранён"); };
    clearUserPromptBtn.onclick = () => { state.setSetting("userPrompt", ""); userPromptInput.value = ""; showToast("Промпт очищен"); };

    // Listeners
    newChatBtn.onclick = () => { state.addChat(); showToast("Создан новый чат"); };
    sendBtn.onclick = sendMessage;
    inputEl.addEventListener("input", (e) => {
      e.target.style.height = 'auto';
      e.target.style.height = Math.min(e.target.scrollHeight, window.innerHeight*0.4) + 'px';
    });
    inputEl.addEventListener("keydown", (e) => { if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendMessage(); } });

    // Settings drawer
    settingsBtn.onclick = () => {
      const opened = settingsPanel.classList.toggle("open");
      if (opened) sidebar.classList.remove("open");
    };

    // Data management
    clearChatsBtn.onclick = () => { if (confirm("Удалить все чаты? Это действие необратимо.")) { state.clearChats(); showToast("Все чаты удалены"); } };
    deleteAccountBtn.onclick = () => {
      if (confirm("Навсегда удалить учётку и данные? Это действие НЕОБРАТИМО.")) {
        store.clear(); state.data = { chats: [], settings: {} }; state.currentChatId = null;
        loadSettings(); renderChatList(); renderChat(); showToast("Учётка и данные удалены");
      }
    };

    // Search
    searchInput.addEventListener("input", (e) => {
      const query = e.target.value.toLowerCase();
      document.querySelectorAll('#chatList .chat-item').forEach(item => {
        item.style.display = item.textContent.toLowerCase().includes(query) ? 'flex' : 'none';
      });
    });
    document.addEventListener("keydown", (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "k") { e.preventDefault(); searchInput.focus(); }
    });
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") { settingsPanel.classList.remove("open"); sidebar.classList.remove("open"); }
    });

    // Model changes
    modelSelect.addEventListener("change", saveSettings);
    themeToggle.addEventListener("change", saveSettings);
    starsToggle.addEventListener("change", () => {
      document.getElementById("stars").style.display = starsToggle.checked ? "block" : "none";
      saveSettings();
    });
    notifyToggle.addEventListener("change", saveSettings);

    // Init
    if (!state.data.chats.length) state.addChat();
    if (!state.currentChatId) state.currentChatId = state.data.chats[0].id;
    loadSettings(); renderChatList(); renderChat();
    inputEl.focus();
  </script>
</body>
</html>
